Index: src/bzfs/CmdLineOptions.cxx
===================================================================
--- src/bzfs/CmdLineOptions.cxx	(revision 22828)
+++ src/bzfs/CmdLineOptions.cxx	(working copy)
@@ -73,6 +73,7 @@
 "[-disableBots] "
 "[+f {good|<id>}] "
 "[-f {bad|<id>}] "
+"[-fancy] "
 "[-fb] "
 "[-filterCallsigns] "
 "[-filterChat] "
@@ -180,6 +181,7 @@
 "\t-disableBots: disallow clients from using autopilot or robots\n"
 "\t+f: always have flag <id> available\n"
 "\t-f: never randomly generate flag <id>\n"
+"\t-fancy: use random arcs\n"
 "\t-fb: allow flags on box buildings\n"
 "\t-filterCallsigns: filter callsigns to disallow inappropriate user names\n"
 "\t-filterChat: filter chat messages\n"
@@ -714,6 +716,9 @@
       checkArgc(1, i, argc, argv[i]);
       storedFlagCounts.push_back(argv[i]);
     }
+    else if (strcmp(argv[i], "-fancy") == 0) {
+      options.fancy = true;
+    }
     else if (strcmp(argv[i], "-fb") == 0) {
       // flags on buildings
       options.flagsOnBuildings = true;
Index: src/bzfs/WorldInfo.h
===================================================================
--- src/bzfs/WorldInfo.h	(revision 22828)
+++ src/bzfs/WorldInfo.h	(working copy)
@@ -91,6 +91,9 @@
 		     bool horizontal, bool drive = false, bool shoot = false, bool rico = false);
   void addBase(const float pos[3], float r, const float size[3],
 	       int color, bool drive = false, bool shoot = false, bool rico = false);
+  void addSphere(float x, float y, float z, int divisions);
+  void addArc(float x, float y, float z, float r, float w, float d, int divisions);
+  void addCone(float x, float y, float z, int divisions);
 
   float getWaterLevel() const;
   float getMaxWorldHeight() const;
Index: src/bzfs/WorldInfo.cxx
===================================================================
--- src/bzfs/WorldInfo.cxx	(revision 22828)
+++ src/bzfs/WorldInfo.cxx	(working copy)
@@ -84,7 +84,105 @@
   OBSTACLEMGR.addWorldObstacle(wall);
 }
 
+void WorldInfo::addArc(float x, float y, float z, float r, float w , float d, int divisions )
+{
+  MeshTransform xform;
+ 
+  const float pos[3] = {x, y, z};
+  const float _size[3] = {r, w, d};
+  const float texsize[4] = {-8.0f, -8.0f, -8.0f, -8.0f};
+ 
+  const float flipScale[3] = {1.0f, 1.0f, 1.0f};
+  const float flipShift[3] = {0.0f, 0.0f, 0.0f};
+  const float flipShear[3] = {0.0f, 0.0f, 0.0f};
+ 
+  xform.addScale(flipScale);
+  xform.addShift(flipShift);
+  xform.addShear(flipShear);
+ 
+  BzMaterial materials[6];
+  materials[0].setTexture("roof");
+  materials[1].setTexture("root");
+  materials[2].setTexture("boxwall");
+  materials[3].setTexture("boxwall");
+  materials[4].setTexture("wall");
+  materials[5].setTexture("wall");
+ 
+  const BzMaterial* mats[6];
+ 
+  for (int i=0; i < 6; i++)
+    mats[i] = MATERIALMGR.addMaterial(&materials[i]);
+ 
+  ArcObstacle* arc = new ArcObstacle(xform, pos, _size, 0.0f,360, 1,texsize, true, divisions, mats, -1, false, false, false, true );
+  OBSTACLEMGR.addWorldObstacle(arc);
+}
 
+void WorldInfo::addCone(float x, float y, float z, int divisions)
+{
+  MeshTransform xform;
+  const float pos[3] = {x, y, z};
+  const float _size[3] = {8.0f, 8.0f, 15.0f};
+  const float diffuse[4] = {0.5f, 0.5f, 0.5f, 0.5f};
+  const float texsize[2] = {-4.0f, -4.0f};
+ 
+  const float flipScale[3] = {1.0f, 1.0f, 1.0f};
+  const float flipShift[3] = {0.0f, 0.0f, 0.0f};
+  const float flipShear[3] = {0.0f, 0.0f, 0.0f};
+ 
+ 
+  xform.addScale(flipScale);
+  xform.addShift(flipShift);
+  xform.addShear(flipShear);
+ 
+  BzMaterial materials[4];
+  /*
+  materials[0].setTexture("boxwall");
+  materials[1].setTexture("roof");
+  materials[2].setTexture("wall");
+  materials[3].setTexture("wall");
+  */
+ 
+  materials[0].setDiffuse(diffuse);
+  materials[1].setDiffuse(diffuse);
+  materials[2].setDiffuse(diffuse);
+  materials[3].setDiffuse(diffuse);
+ 
+  const BzMaterial* mats[4];
+  for (int i=0; i < 4; i++)
+     mats[i] = MATERIALMGR.addMaterial(&materials[i]);
+ 
+  ConeObstacle* cone = new ConeObstacle(xform, pos, _size, 0.0f,360, texsize, true, divisions, mats, -1, true, false, false, true );
+ 
+  OBSTACLEMGR.addWorldObstacle(cone);
+}
+
+void WorldInfo::addSphere(float x, float y, float z , int divisions)
+{
+  MeshTransform xform;
+  const float pos[3] = {x, y, z};
+  const float _size[3] = {10.0f, 10.0f, -10.0f};
+  const float texsize[2] = {-4.0f, -4.0f};
+ 
+  const float flipScale[3] = {1.0f, 1.0f, 1.0f};
+  const float flipShift[3] = {1.0f, 1.0f, 1.0f};
+  const float flipShear[3] = {0.0f, 0.0f, 0.0f};
+  xform.addScale(flipScale);
+  xform.addShift(flipShift);
+  xform.addShear(flipShear);
+ 
+  BzMaterial materials[2];
+  materials[0].setTexture("tetrawall");
+  materials[1].setTexture("roof");
+ 
+  const BzMaterial* mats[2];
+  mats[0] = MATERIALMGR.addMaterial(&materials[0]);
+  mats[1] = MATERIALMGR.addMaterial(&materials[1]);
+ 
+  SphereObstacle* sphere = new SphereObstacle(xform, pos, _size, 0.0f, texsize, true, false, divisions, mats, -1, true, false, false, true );
+ 
+  OBSTACLEMGR.addWorldObstacle(sphere);
+}
+
 void WorldInfo::addLink(int src, int dst)
 {
   links.addLink(src, dst);
Index: src/bzfs/CmdLineOptions.h
===================================================================
--- src/bzfs/CmdLineOptions.h	(revision 22828)
+++ src/bzfs/CmdLineOptions.h	(working copy)
@@ -73,7 +73,7 @@
     idlekickthresh(-1.0), timeLimit(0.0f), timeElapsed(0.0f), addedTime(0.0f),
     linearAcceleration(_DEFAULT_LIN_ACCEL), angularAcceleration(_DEFAULT_ANGLE_ACCELL), useGivenPort(false),
     useFallbackPort(false), UPnP(false), randomBoxes(false),
-    randomCTF(false), flagsOnBuildings(false), respawnOnBuildings(false),
+    randomCTF(false), fancy(false), flagsOnBuildings(false), respawnOnBuildings(false),
     oneGameOnly(false), timeManualStart(false), randomHeights(false),
     useTeleporters(false), teamKillerDies(true), printScore(false),
     publicizeServer(false), replayServer(false), startRecording(false),
@@ -155,6 +155,7 @@
   bool			UPnP;
   bool			randomBoxes;
   bool			randomCTF;
+  bool      fancy;
   bool			flagsOnBuildings;
   bool			respawnOnBuildings;
   bool			oneGameOnly;
Index: src/bzfs/WorldGenerators.cxx
===================================================================
--- src/bzfs/WorldGenerators.cxx	(revision 22828)
+++ src/bzfs/WorldGenerators.cxx	(working copy)
@@ -77,6 +77,44 @@
 	pyrBase, pyrBase, h);
   }
 
+  if (clOptions->fancy) {
+
+    // make arcs
+    const int numArcs = int((0.5f + 0.7f * bzfrand()) * actCitySize * actCitySize);
+
+    for (i = 0; i < numArcs; i++) {
+      myWorld->addArc(worldSize * ((float)bzfrand() - 0.5f),
+      worldSize * ((float)bzfrand() - 0.5f), 0.0f, 15, 15, 15, 24);
+ 
+      myWorld->addArc(worldSize * ((float)bzfrand() - 0.5f),
+      worldSize * ((float)bzfrand() - 0.5f), 0.0f, 15, 15, 15, 3);
+ 
+      myWorld->addArc(worldSize * ((float)bzfrand() - 0.5f),
+      worldSize * ((float)bzfrand() - 0.5f), 0.0f, 15, 15, 15, 6);
+     }
+ 
+     // make cones
+     const int numCones = int((0.5f + 0.7f * bzfrand()) * actCitySize * actCitySize);
+     float x,y;
+ 
+     for (i = 0; i < numCones; i++) {
+       x = worldSize * ((float)bzfrand() - 0.5f);
+       y = worldSize * ((float)bzfrand() - 0.5f);
+   
+       myWorld->addCone(x,y,0.0f, 16);
+       myWorld->addSphere(x + 20,y,20.0f, 4);
+     }
+   
+     // make spheres
+     /*
+     const int numSpheres = int((0.5f + 0.7f * bzfrand()) * actCitySize * actCitySize);
+   
+     for (i = 0; i < numSpheres; i++) {
+         myWorld->addSphere(worldSize * ((float)bzfrand() - 0.5f),
+         worldSize * ((float)bzfrand() - 0.5f),9.0f, 4);
+      }*/
+  }
+
   if (clOptions->useTeleporters) {
     // make teleporters
     float teleBreadth = BZDB.eval(StateDatabase::BZDB_TELEBREADTH);
